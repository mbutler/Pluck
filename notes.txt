const soundProperties = new WeakMap()

class Sound {
  constructor(options = {}) {
    const audioContext = options.context || new (window.AudioContext || window.webkitAudioContext)()
    const gainNode = audioContext.createGain()
    const properties = {
      context: audioContext,
      source: null,
      audioBuffer: options.audioBuffer || null,
      volume: options.volume || 1,
      loop: options.loop || false,
      attack: options.attack || 0.04,
      release: options.release || 0.04,
      gainNode,
      mediaStream: options.input || null,
      clearBuffer: options.clearBuffer || false,
      isPlaying: false,
      range: {
        start: options.range?.start || 0,
        end: options.range?.end || null // end will be set later based on buffer duration
      }
    }
    soundProperties.set(this, properties)

    this.initialized = this.initialize(options)
  }

  async initialize(options) {
    try {
      await this.initSource(options)
      this.volume = options.volume || 1

      const properties = soundProperties.get(this)
      if (!properties.range.end && properties.audioBuffer) {
        properties.range.end = properties.audioBuffer.duration
      }
    } catch (error) {
      console.error('Error initializing source:', error)
    }
  }

  get context() {
    return soundProperties.get(this).context
  }

  get source() {
    return soundProperties.get(this).source
  }

  set source(value) {
    const properties = soundProperties.get(this)
    properties.source = value
  }

  get audioBuffer() {
    return soundProperties.get(this).audioBuffer
  }

  set audioBuffer(value) {
    const properties = soundProperties.get(this)
    properties.audioBuffer = value
    if (!properties.range.end) {
      properties.range.end = value.duration
    }
  }

  get volume() {
    return soundProperties.get(this).volume
  }

  set volume(value) {
    const properties = soundProperties.get(this)
    properties.volume = value
    if (properties.gainNode) {
      properties.gainNode.gain.value = value
    }
  }

  get loop() {
    return soundProperties.get(this).loop
  }

  set loop(value) {
    const properties = soundProperties.get(this)
    properties.loop = value
  }

  get attack() {
    return soundProperties.get(this).attack
  }

  set attack(value) {
    const properties = soundProperties.get(this)
    properties.attack = value
  }

  get release() {
    return soundProperties.get(this).release
  }

  set release(value) {
    const properties = soundProperties.get(this)
    properties.release = value
  }

  get gainNode() {
    return soundProperties.get(this).gainNode
  }

  get mediaStream() {
    return soundProperties.get(this).mediaStream
  }

  set mediaStream(value) {
    const properties = soundProperties.get(this)
    properties.mediaStream = value
  }

  get clearBuffer() {
    return soundProperties.get(this).clearBuffer
  }

  set clearBuffer(value) {
    const properties = soundProperties.get(this)
    properties.clearBuffer = value
  }

  get isPlaying() {
    return soundProperties.get(this).isPlaying
  }

  set isPlaying(value) {
    const properties = soundProperties.get(this)
    properties.isPlaying = value
  }

  get range() {
    return soundProperties.get(this).range
  }

  set range(value) {
    const properties = soundProperties.get(this)
    properties.range = { ...properties.range, ...value }
    if (!properties.range.end && properties.audioBuffer) {
      properties.range.end = properties.audioBuffer.duration
    }
  }

  async initSource(options) {
    if (options.file) {
      await this.loadFromFile(options.file)
    } else if (options.wave) {
      this.initFromWave(options.wave)
    } else if (options.input) {
      await this.initFromInput()
    } else {
      this.initFromWave({ type: 'sine', frequency: 440 })
    }
  }

  async loadFromFile(file) {
    try {
      console.log('Fetching sound file:', file)
      const response = await fetch(file)
      if (!response.ok) {
        throw new Error(`Network response was not ok: ${response.statusText}`)
      }
      const arrayBuffer = await response.arrayBuffer()
      const properties = soundProperties.get(this)
      properties.audioBuffer = await this.context.decodeAudioData(arrayBuffer)
      if (!properties.range.end) {
        properties.range.end = properties.audioBuffer.duration
      }
      console.log('Sound file loaded:', file)
    } catch (error) {
      console.error('Error loading sound file:', error)
    }
  }

  createSourceFromBuffer() {
    const properties = soundProperties.get(this)
    if (!properties.audioBuffer) {
      console.error('No audio buffer to create source from')
      return
    }
    properties.source = this.context.createBufferSource()
    properties.source.buffer = properties.audioBuffer
    properties.source.loop = properties.loop
    properties.source.loopStart = properties.range.start
    properties.source.loopEnd = properties.range.end
    properties.source.onended = () => {
      console.log('Sound playback ended')
      properties.isPlaying = false
      properties.source = null
      if (properties.clearBuffer) properties.audioBuffer = null
    }
    properties.source.connect(properties.gainNode)
  }

  async play(offset = 0) {
    const properties = soundProperties.get(this)
    if (properties.isPlaying) {
      console.log('Sound is already playing')
      return
    }
    properties.isPlaying = true
    this.createSourceFromBuffer() // Ensure a new source node is created
    this.applyAttack()
    console.log('Starting source', properties.source)
    properties.source.start(this.context.currentTime, offset)
  }

  stop() {
    const properties = soundProperties.get(this)
    properties.isPlaying = false
    if (properties.mediaStream) {
      properties.mediaStream.getTracks().forEach(track => track.stop())
      properties.source.disconnect()
      properties.source = null
      console.log('Microphone input stopped')
      return
    }
    if (properties.source && properties.source.stop) {
      this.applyRelease(() => {
        properties.source.stop()
        properties.source.disconnect()
        properties.source = null
        if (properties.clearBuffer) properties.audioBuffer = null
        console.log('Stopping sound')
      })
    }
  }

  clone() {
    const properties = soundProperties.get(this)
    return new Sound({
      context: properties.context,
      audioBuffer: properties.audioBuffer,
      volume: properties.volume,
      loop: properties.loop,
      attack: properties.attack,
      release: properties.release,
      input: this.mediaStream || null,
      clearBuffer: properties.clearBuffer,
      range: properties.range,
      file: this.source && this.source.buffer ? this.source.buffer : undefined,
      wave: this.source && this.source.frequency ? { type: this.source.type, frequency: this.source.frequency.value } : undefined,
    })
  }

  applyAttack() {
    const properties = soundProperties.get(this)
    if (!properties.gainNode) return
    const currentTime = this.context.currentTime
    properties.gainNode.gain.setValueAtTime(0, currentTime)
    properties.gainNode.gain.linearRampToValueAtTime(properties.volume, currentTime + properties.attack)
    console.log('Attack applied')
  }

  applyRelease(callback) {
    const properties = soundProperties.get(this)
    if (!properties.gainNode) return
    const currentTime = this.context.currentTime
    properties.gainNode.gain.setValueAtTime(properties.volume, currentTime)
    properties.gainNode.gain.linearRampToValueAtTime(0, currentTime + properties.release)
    properties.gainNode.gain.setValueAtTime(0, currentTime + properties.release + 0.01)
    console.log('Release applied')
    setTimeout(callback, properties.release * 1000)
  }

  connect(node) {
    const properties = soundProperties.get(this)
    properties.gainNode.connect(node)
  }

  disconnect(node) {
    const properties = soundProperties.get(this)
    properties.gainNode.disconnect(node)
  }
}

export default Sound
