var u=new(window.AudioContext||window.webkitAudioContext),r=new WeakMap;class s{constructor(e={}){const t=u.createGain(),o={context:u,source:null,audioBuffer:null,volume:e.volume||1,loop:e.loop||!1,attack:e.attack||0.04,release:e.release||0.04,gainNode:t,isMicrophone:e.input||!1,mediaStream:null};r.set(this,o),this.initialized=this.initSource(e).then(()=>{this.volume=o.volume})}get context(){return r.get(this).context}get source(){return r.get(this).source}set source(e){const t=r.get(this);t.source=e}get volume(){return r.get(this).volume}set volume(e){const t=r.get(this);if(e<0||e>1){console.warn("Volume value must be between 0 and 1.");return}if(t.volume=e,t.gainNode)t.gainNode.gain.value=e}get loop(){return r.get(this).loop}set loop(e){r.get(this).loop=e}get attack(){return r.get(this).attack}set attack(e){r.get(this).attack=e}get release(){return r.get(this).release}set release(e){r.get(this).release=e}get gainNode(){return r.get(this).gainNode}async initSource(e){if(e.file)await this.loadFromFile(e.file);else if(e.wave)this.initFromWave(e.wave);else if(e.input)await this.initFromInput();else if(e.audioFunction)this.initFromFunction(e.audioFunction);else this.initFromWave({type:"sine",frequency:440})}async loadFromFile(e){const t=r.get(this);try{console.log("Fetching sound file:",e);const i=await(await fetch(e)).arrayBuffer(),a=await t.context.decodeAudioData(i);t.audioBuffer=a,console.log("Sound file loaded:",e)}catch(o){console.error("Error loading sound file:",o)}}createSourceFromBuffer(){const e=r.get(this);if(!e.audioBuffer){console.error("No audio buffer to create source from");return}e.source=e.context.createBufferSource(),e.source.buffer=e.audioBuffer,e.source.loop=e.loop,e.source.onended=()=>{console.log("Sound playback ended"),e.source=null},console.log("Created source from buffer:",e.source),this.connectSourceToGainNode()}initFromWave(e){const t=r.get(this);t.source=t.context.createOscillator(),t.source.type=e.type||"sine",t.source.frequency.value=e.frequency||440,t.source.onended=()=>{console.log("Sound playback ended"),t.source=null},this.connectSourceToGainNode()}async initFromInput(){const e=r.get(this),t=await navigator.mediaDevices.getUserMedia({audio:!0});e.mediaStream=t,e.source=e.context.createMediaStreamSource(t),this.connectSourceToGainNode()}initFromFunction(e){const t=r.get(this);t.source=t.context.createScriptProcessor(2048,1,1),t.source.onaudioprocess=e,this.connectSourceToGainNode()}connectSourceToGainNode(){const e=r.get(this);if(e.source)e.source.connect(e.gainNode),e.gainNode.connect(e.context.destination),console.log("Source connected to gain node");else console.error("No source to connect to gain node")}async play(e=0,t=0){await this.initialized;const o=r.get(this);if(o.context.state==="suspended")await o.context.resume();if(!o.audioBuffer&&!o.source){console.error("No audio buffer or source available to play");return}if(o.audioBuffer)this.createSourceFromBuffer();if(o.source&&o.source.start){console.log("Applying attack"),this.applyAttack();const i=t;o.startTime=o.context.currentTime-i,console.log("Starting source",o.source),o.source.start(o.context.currentTime+e,i),o.isPlaying=!0,console.log("Playing sound")}else console.error("No source to play")}stop(){const e=r.get(this);if(e.isMicrophone&&e.mediaStream){e.mediaStream.getTracks().forEach((t)=>t.stop()),e.source.disconnect(e.gainNode),e.source=null,console.log("Microphone input stopped");return}if(e.source&&e.source.stop)this.applyRelease(()=>{if(e.source.stop(),e.source=null,e.clearBuffer)this.cleanupAudioBuffer();console.log("Stopping sound")});else console.error("No source to stop")}clone(){const e=r.get(this),t=e.source&&typeof e.source.mediaStream!=="undefined";return new s({volume:e.volume,loop:e.loop,attack:e.attack,release:e.release,file:e.source&&e.source.buffer?e.source.buffer:void 0,wave:e.source&&e.source.frequency?{type:e.source.type,frequency:e.source.frequency.value}:void 0,input:t,audioFunction:e.source.onaudioprocess})}setVolume(e){this.volume=e}applyAttack(){const e=r.get(this);if(!e.gainNode)return;const t=e.context.currentTime;e.gainNode.gain.setValueAtTime(0,t),e.gainNode.gain.linearRampToValueAtTime(e.volume,t+e.attack),console.log("Attack applied")}applyRelease(e){const t=r.get(this);if(!t.gainNode)return;const o=t.context.currentTime;t.gainNode.gain.setValueAtTime(t.volume,o),t.gainNode.gain.linearRampToValueAtTime(0,o+t.release),setTimeout(e,t.release*1000),console.log("Release applied")}cleanupAudioBuffer(){const e=r.get(this);e.audioBuffer=null,console.log("Audio buffer cleaned up")}connect(e){r.get(this).gainNode.connect(e)}disconnect(e){r.get(this).gainNode.disconnect(e)}}var n=s;var c=new WeakMap;class l{constructor(e=[]){if(e.length===0)throw new Error("Group requires at least one sound");const t=e[0].context,o=t.createGain(),i={context:t,gainNode:o,sounds:e};c.set(this,i),e.forEach((a)=>{if(a instanceof n)a.connect(o),console.log("Sound connected to group gain node:",a);else console.error("Sound is not an instance of Sound class:",a)}),o.connect(t.destination)}get context(){return c.get(this).context}get gainNode(){return c.get(this).gainNode}get sounds(){return c.get(this).sounds}play(){this.sounds.forEach((e)=>e.play())}stop(){this.sounds.forEach((e)=>e.stop())}pause(){this.sounds.forEach((e)=>e.pause())}addSound(e){if(!(e instanceof n)){console.error("The sound is not an instance of Sound class:",e);return}const t=c.get(this);t.sounds.push(e),e.connect(t.gainNode),console.log("Added and connected new sound to group gain node:",e)}removeSound(e){const t=c.get(this),o=t.sounds.indexOf(e);if(o===-1){console.warn("The sound is not in the group");return}e.disconnect(t.gainNode),t.sounds.splice(o,1),console.log("Removed and disconnected sound from group gain node:",e)}set volume(e){if(e<0||e>1){console.warn("Volume value must be between 0 and 1.");return}c.get(this).gainNode.gain.value=e}get volume(){return c.get(this).gainNode.gain.value}}var f=l;window.Pluck={Sound:n,Group:f};
