var Q=new(window.AudioContext||window.webkitAudioContext),A=new WeakMap;class L{constructor(q={}){const z=Q.createGain(),D={context:Q,source:null,audioBuffer:null,volume:q.volume||1,loop:q.loop||!1,attack:q.attack||0.04,release:q.release||0.04,gainNode:z,clearBuffer:q.clearBuffer||!1};A.set(this,D),this.initialized=this.initSource(q).then(()=>{this.volume=D.volume})}get context(){return A.get(this).context}get source(){return A.get(this).source}set source(q){const z=A.get(this);z.source=q}get volume(){return A.get(this).volume}set volume(q){const z=A.get(this);if(q<0||q>1){console.warn("Volume value must be between 0 and 1.");return}if(z.volume=q,z.gainNode)z.gainNode.gain.value=q}get loop(){return A.get(this).loop}set loop(q){A.get(this).loop=q}get attack(){return A.get(this).attack}set attack(q){A.get(this).attack=q}get release(){return A.get(this).release}set release(q){A.get(this).release=q}get gainNode(){return A.get(this).gainNode}async initSource(q){if(q.file)await this.loadFromFile(q.file);else if(q.wave)this.initFromWave(q.wave);else if(q.input)await this.initFromInput();else if(q.audioFunction)this.initFromFunction(q.audioFunction);else this.initFromWave({type:"sine",frequency:440})}async loadFromFile(q){const z=A.get(this);try{console.log("Fetching sound file:",q);const K=await(await fetch(q)).arrayBuffer(),H=await z.context.decodeAudioData(K);z.audioBuffer=H,console.log("Sound file loaded:",q)}catch(D){console.error("Error loading sound file:",D)}}createSourceFromBuffer(){const q=A.get(this);if(!q.audioBuffer){console.error("No audio buffer to create source from");return}q.source=q.context.createBufferSource(),q.source.buffer=q.audioBuffer,q.source.loop=q.loop,q.source.onended=()=>{if(console.log("Sound playback ended"),q.source=null,q.clearBuffer)this.cleanupAudioBuffer()},console.log("Created source from buffer:",q.source),this.connectSourceToGainNode()}initFromWave(q){const z=A.get(this);z.source=z.context.createOscillator(),z.source.type=q.type||"sine",z.source.frequency.value=q.frequency||440,z.source.onended=()=>{console.log("Sound playback ended"),z.source=null},this.connectSourceToGainNode()}async initFromInput(){const q=A.get(this),z=await navigator.mediaDevices.getUserMedia({audio:!0});q.source=q.context.createMediaStreamSource(z),this.connectSourceToGainNode()}initFromFunction(q){const z=A.get(this);z.source=z.context.createScriptProcessor(2048,1,1),z.source.onaudioprocess=q,this.connectSourceToGainNode()}connectSourceToGainNode(){const q=A.get(this);if(q.source)q.source.connect(q.gainNode),q.gainNode.connect(q.context.destination),console.log("Source connected to gain node");else console.error("No source to connect to gain node")}async play(q=0,z=0){await this.initialized;const D=A.get(this);if(D.context.state==="suspended")await D.context.resume();if(!D.audioBuffer&&!D.source){console.error("No audio buffer or source available to play");return}if(D.audioBuffer)this.createSourceFromBuffer();if(D.source&&D.source.start)console.log("Applying attack"),this.applyAttack(),console.log("Starting source",D.source),D.source.start(D.context.currentTime+q,z),console.log("Playing sound");else console.error("No source to play")}pause(){}stop(){const q=A.get(this);if(q.source&&q.source.stop)this.applyRelease(()=>{if(q.source.stop(),q.source=null,q.clearBuffer)this.cleanupAudioBuffer();console.log("Stopping sound")});else console.error("No source to stop")}clone(){const q=A.get(this),z=q.source&&typeof q.source.mediaStream!=="undefined";return new L({volume:q.volume,loop:q.loop,attack:q.attack,release:q.release,file:q.source&&q.source.buffer?q.source.buffer:void 0,wave:q.source&&q.source.frequency?{type:q.source.type,frequency:q.source.frequency.value}:void 0,input:z,audioFunction:q.source.onaudioprocess,clearBuffer:q.clearBuffer})}setVolume(q){this.volume=q}applyAttack(){const q=A.get(this);if(!q.gainNode)return;const z=q.context.currentTime;q.gainNode.gain.setValueAtTime(0,z),q.gainNode.gain.linearRampToValueAtTime(q.volume,z+q.attack),console.log("Attack applied")}applyRelease(q){const z=A.get(this);if(!z.gainNode)return;const D=z.context.currentTime;z.gainNode.gain.setValueAtTime(z.volume,D),z.gainNode.gain.linearRampToValueAtTime(0,D+z.release),setTimeout(q,z.release*1000),console.log("Release applied")}cleanupAudioBuffer(){const q=A.get(this);q.audioBuffer=null,console.log("Audio buffer cleared from memory")}connect(q){A.get(this).gainNode.connect(q)}disconnect(q){A.get(this).gainNode.disconnect(q)}}var J=L;var E=new WeakMap;class R{constructor(q=[]){if(q.length===0)throw new Error("Group requires at least one sound");const z=q[0].context,D=z.createGain(),K={context:z,gainNode:D,sounds:q};E.set(this,K),q.forEach((H)=>{if(H instanceof J)H.connect(D),console.log("Sound connected to group gain node:",H);else console.error("Sound is not an instance of Sound class:",H)}),D.connect(z.destination)}get context(){return E.get(this).context}get gainNode(){return E.get(this).gainNode}get sounds(){return E.get(this).sounds}play(){this.sounds.forEach((q)=>q.play())}stop(){this.sounds.forEach((q)=>q.stop())}pause(){this.sounds.forEach((q)=>q.pause())}addSound(q){if(!(q instanceof J)){console.error("The sound is not an instance of Sound class:",q);return}const z=E.get(this);z.sounds.push(q),q.connect(z.gainNode),console.log("Added and connected new sound to group gain node:",q)}removeSound(q){const z=E.get(this),D=z.sounds.indexOf(q);if(D===-1){console.warn("The sound is not in the group");return}q.disconnect(z.gainNode),z.sounds.splice(D,1),console.log("Removed and disconnected sound from group gain node:",q)}set volume(q){if(q<0||q>1){console.warn("Volume value must be between 0 and 1.");return}E.get(this).gainNode.gain.value=q}get volume(){return E.get(this).gainNode.gain.value}}var V=R;window.Pluck={Sound:J,Group:V};
