var o=new WeakMap;class a{constructor(e={}){const t=e.context||new(window.AudioContext||window.webkitAudioContext),i=t.createGain(),s={context:t,source:null,audioBuffer:e.audioBuffer||null,volume:e.volume||1,loop:e.loop||!1,attack:e.attack||0.04,release:e.release||0.04,gainNode:i,isMicrophone:e.input||!1,mediaStream:null,clearBuffer:e.clearBuffer||!1,isPlaying:!1};o.set(this,s),this.initialized=this.initialize(e)}async initialize(e){try{await this.initSource(e),this.volume=e.volume||1}catch(t){console.error("Error initializing source:",t)}}get context(){return o.get(this).context}get source(){return o.get(this).source}set source(e){const t=o.get(this);t.source=e}get volume(){return o.get(this).volume}set volume(e){const t=o.get(this);if(e<0||e>1){console.warn("Volume value must be between 0 and 1.");return}if(t.volume=e,t.gainNode)t.gainNode.gain.value=e}get loop(){return o.get(this).loop}set loop(e){o.get(this).loop=e}get attack(){return o.get(this).attack}set attack(e){o.get(this).attack=e}get release(){return o.get(this).release}set release(e){o.get(this).release=e}get gainNode(){return o.get(this).gainNode}get isPlaying(){return o.get(this).isPlaying}set isPlaying(e){const t=o.get(this);t.isPlaying=e}async initSource(e){if(e.file)await this.loadFromFile(e.file);else if(e.wave)this.initFromWave(e.wave);else if(e.input)await this.initFromInput();else if(e.audioFunction)this.initFromFunction(e.audioFunction);else this.initFromWave({type:"sine",frequency:440})}async loadFromFile(e){const t=o.get(this);try{console.log("Fetching sound file:",e);const s=await(await fetch(e)).arrayBuffer(),c=await t.context.decodeAudioData(s);t.audioBuffer=c,console.log("Sound file loaded:",e)}catch(i){console.error("Error loading sound file:",i)}}createSourceFromBuffer(){const e=o.get(this);if(!e.audioBuffer){console.error("No audio buffer to create source from");return}this.source=e.context.createBufferSource(),this.source.buffer=e.audioBuffer,this.source.loop=e.loop,this.source.onended=()=>{if(console.log("Sound playback ended"),this.isPlaying=!1,this.source=null,e.clearBuffer)this.cleanupAudioBuffer()},console.log("Created source from buffer:",this.source),this.connectSourceToGainNode()}initFromWave(e){const t=o.get(this);this.source=t.context.createOscillator(),this.source.type=e.type||"sine",this.source.frequency.value=e.frequency||440,this.source.onended=()=>{console.log("Sound playback ended"),this.isPlaying=!1,this.source=null},this.connectSourceToGainNode()}async initFromInput(){const e=o.get(this);try{const t=await navigator.mediaDevices.getUserMedia({audio:!0});this.mediaStream=t,this.source=e.context.createMediaStreamSource(t),this.connectSourceToGainNode()}catch(t){console.error("Error initializing microphone input:",t)}}initFromFunction(e){const t=o.get(this);this.source=t.context.createScriptProcessor(2048,1,1),this.source.onaudioprocess=e,this.connectSourceToGainNode()}connectSourceToGainNode(){const e=o.get(this);if(this.source)this.source.connect(e.gainNode),e.gainNode.connect(e.context.destination),console.log("Source connected to gain node");else console.error("No source to connect to gain node")}async play(e=0){await this.initialized;const t=o.get(this);if(t.context.state==="suspended")await t.context.resume();if(!t.audioBuffer&&!t.source){console.error("No audio buffer or source available to play");return}if(t.audioBuffer)this.createSourceFromBuffer();while(!t.source)await new Promise((i)=>setTimeout(i,10));if(t.source&&t.source.start){console.log("Applying attack"),this.applyAttack();const i=e;t.startTime=t.context.currentTime-i,console.log("Starting source",t.source),t.source.start(t.context.currentTime,i),this.isPlaying=!0,console.log("Playing sound")}}stop(){const e=o.get(this);if(e.isMicrophone&&this.mediaStream){this.mediaStream.getTracks().forEach((t)=>t.stop()),this.source.disconnect(e.gainNode),this.source=null,console.log("Microphone input stopped");return}if(this.source&&this.source.stop)this.applyRelease(()=>{if(this.source.stop(),this.isPlaying=!1,this.source=null,this.clearBuffer)this.cleanupAudioBuffer();console.log("Stopping sound")});else console.error("No source to stop")}clone(){const e=o.get(this),t=this.source&&typeof this.source.mediaStream!=="undefined";return new a({volume:this.volume,loop:this.loop,attack:this.attack,release:this.release,file:this.source&&this.source.buffer?this.source.buffer:void 0,wave:this.source&&this.source.frequency?{type:this.source.type,frequency:this.source.frequency.value}:void 0,input:t,audioFunction:this.source.onaudioprocess})}setVolume(e){this.volume=e}applyAttack(){const e=o.get(this);if(!e.gainNode)return;const t=e.context.currentTime;e.gainNode.gain.setValueAtTime(0,t),e.gainNode.gain.linearRampToValueAtTime(this.volume,t+this.attack),console.log("Attack applied")}applyRelease(e){const t=o.get(this);if(!t.gainNode)return;const i=t.context.currentTime;t.gainNode.gain.setValueAtTime(this.volume,i),t.gainNode.gain.linearRampToValueAtTime(0,i+this.release),setTimeout(e,this.release*1000),console.log("Release applied")}cleanupAudioBuffer(){const e=o.get(this);e.audioBuffer=null,console.log("Audio buffer cleaned up")}connect(e){o.get(this).gainNode.connect(e)}disconnect(e){o.get(this).gainNode.disconnect(e)}}var n=a;class u{constructor(){this.context=null,this.sounds=[],this.startTime=null,this.currentTime=0,this.lastTimestamp=0,this.isPlaying=!1}start(){this.context=new(window.AudioContext||window.webkitAudioContext),console.log("Audio context initialized",this.context),this.startTime=this.context.currentTime,console.log("Timeline started",this.startTime),this.isPlaying=!0,this.loop()}async loop(){if(!this.isPlaying)return;if(this.currentTime=this.context.currentTime-this.startTime,await this.playScheduledSounds(),this.currentTime-this.lastTimestamp>=1)this.lastTimestamp=this.currentTime,this.runEverySecond();requestAnimationFrame(()=>this.loop())}stop(){this.isPlaying=!1}scheduleSound(e,t,i=0,s={}){this.sounds.push({sound:e,time:t,offset:i,options:s,played:!1})}async playScheduledSounds(){for(let e of this.sounds){const{sound:t,time:i,offset:s,played:c,options:l}=e;if(this.currentTime>=i&&(!c||l.loop))try{if(await t.play(s),!l.loop)e.played=!0;console.log(`Played sound at ${i} with offset=${s}`)}catch(m){console.error("Error playing sound:",m)}}}async addSound(e,t=0,i,s={}){const c=new n({file:e,context:this.context,...s});await c.initialized,this.scheduleSound(c,i,t,s)}async playSound(e,t=0,i={}){if(!this.context){console.error("Audio context is not initialized. Call start() first.");return}const s=new n({file:e,context:this.context,...i});await s.initialized,await s.play(t)}runEverySecond(){console.log("Every second")}}var h=u;var r=new WeakMap;class f{constructor(e=[]){if(e.length===0)throw new Error("Group requires at least one sound");const t=e[0].context,i=t.createGain(),s={context:t,gainNode:i,sounds:[],muted:!1};r.set(this,s),e.forEach((c)=>{if(c instanceof n)this.addSound(c);else console.error("Sound is not an instance of Sound class:",c)}),i.connect(t.destination)}get context(){return r.get(this).context}get gainNode(){return r.get(this).gainNode}get sounds(){return r.get(this).sounds}async play(){const t=r.get(this).sounds.map(async(i)=>{if(!i.isPlaying)try{await i.play(),i.isPlaying=!0}catch(s){console.error("Error playing sound:",s)}});await Promise.all(t)}async stop(){const t=r.get(this).sounds.map(async(i)=>{if(i.isPlaying)i.stop(),i.isPlaying=!1});await Promise.all(t)}async addSound(e){if(!(e instanceof n)){console.error("The sound is not an instance of Sound class:",e);return}const t=r.get(this);if(e.context!==t.context){console.error("Cannot add sound to group: mismatched audio contexts");return}t.sounds.push(e),e.connect(t.gainNode),console.log("Added and connected new sound to group gain node:",e)}async removeSound(e){const t=r.get(this),i=t.sounds.indexOf(e);if(i===-1){console.warn("The sound is not in the group");return}if(e.disconnect(t.gainNode),t.sounds.splice(i,1),console.log("Removed and disconnected sound from group gain node:",e),t.sounds.length===0)t.gainNode.disconnect(t.context.destination)}set volume(e){if(e<0||e>1){console.warn("Volume value must be between 0 and 1.");return}r.get(this).gainNode.gain.value=e}get volume(){return r.get(this).gainNode.gain.value}setVolumeGradually(e,t=1){if(e<0||e>1){console.warn("Volume value must be between 0 and 1.");return}const i=r.get(this).gainNode,s=this.context.currentTime;i.gain.setValueAtTime(i.gain.value,s),i.gain.linearRampToValueAtTime(e,s+t),console.log(`Volume set to ${e} over ${t} seconds`)}mute(){const e=r.get(this);if(!e.muted)e.previousVolume=this.volume,this.volume=0,e.muted=!0,console.log("Group muted")}unmute(){const e=r.get(this);if(e.muted)this.volume=e.previousVolume,e.muted=!1,console.log("Group unmuted")}}var d=f;window.Pluck={Timeline:h,Sound:n,Group:d};
