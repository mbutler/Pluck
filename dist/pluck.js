var Q=new(window.AudioContext||window.webkitAudioContext),D=new WeakMap;class L{constructor(q={}){const z=Q.createGain(),A={context:Q,source:null,audioBuffer:null,volume:q.volume||1,loop:q.loop||!1,attack:q.attack||0.04,release:q.release||0.04,gainNode:z,isMicrophone:q.input||!1,mediaStream:null};D.set(this,A),this.initialized=this.initSource(q).then(()=>{this.volume=A.volume})}get context(){return D.get(this).context}get source(){return D.get(this).source}set source(q){const z=D.get(this);z.source=q}get volume(){return D.get(this).volume}set volume(q){const z=D.get(this);if(q<0||q>1){console.warn("Volume value must be between 0 and 1.");return}if(z.volume=q,z.gainNode)z.gainNode.gain.value=q}get loop(){return D.get(this).loop}set loop(q){D.get(this).loop=q}get attack(){return D.get(this).attack}set attack(q){D.get(this).attack=q}get release(){return D.get(this).release}set release(q){D.get(this).release=q}get gainNode(){return D.get(this).gainNode}async initSource(q){if(q.file)await this.loadFromFile(q.file);else if(q.wave)this.initFromWave(q.wave);else if(q.input)await this.initFromInput();else if(q.audioFunction)this.initFromFunction(q.audioFunction);else this.initFromWave({type:"sine",frequency:440})}async loadFromFile(q){const z=D.get(this);try{console.log("Fetching sound file:",q);const K=await(await fetch(q)).arrayBuffer(),I=await z.context.decodeAudioData(K);z.audioBuffer=I,console.log("Sound file loaded:",q)}catch(A){console.error("Error loading sound file:",A)}}createSourceFromBuffer(){const q=D.get(this);if(!q.audioBuffer){console.error("No audio buffer to create source from");return}q.source=q.context.createBufferSource(),q.source.buffer=q.audioBuffer,q.source.loop=q.loop,q.source.onended=()=>{console.log("Sound playback ended"),q.source=null},console.log("Created source from buffer:",q.source),this.connectSourceToGainNode()}initFromWave(q){const z=D.get(this);z.source=z.context.createOscillator(),z.source.type=q.type||"sine",z.source.frequency.value=q.frequency||440,z.source.onended=()=>{console.log("Sound playback ended"),z.source=null},this.connectSourceToGainNode()}async initFromInput(){const q=D.get(this),z=await navigator.mediaDevices.getUserMedia({audio:!0});q.mediaStream=z,q.source=q.context.createMediaStreamSource(z),this.connectSourceToGainNode(),console.log("Microphone input initialized")}initFromFunction(q){const z=D.get(this);z.source=z.context.createScriptProcessor(2048,1,1),z.source.onaudioprocess=q,this.connectSourceToGainNode()}connectSourceToGainNode(){const q=D.get(this);if(q.source)q.source.connect(q.gainNode),q.gainNode.connect(q.context.destination),console.log("Source connected to gain node");else console.error("No source to connect to gain node")}async play(q=0,z=0){await this.initialized;const A=D.get(this);if(A.context.state==="suspended")await A.context.resume();if(!A.audioBuffer&&!A.source){console.error("No audio buffer or source available to play");return}if(A.audioBuffer)this.createSourceFromBuffer();if(A.source&&A.source.start)console.log("Applying attack"),this.applyAttack(),console.log("Starting source",A.source),A.source.start(A.context.currentTime+q,z),console.log("Playing sound");else console.log("Playing microphone input")}pause(){}stop(){const q=D.get(this);if(q.source)if(q.isMicrophone&&q.mediaStream)q.mediaStream.getTracks().forEach((z)=>z.stop()),q.source.disconnect(q.gainNode),q.source=null,console.log("Microphone input stopped");else if(q.source.stop)this.applyRelease(()=>{q.source.stop(),q.source=null,console.log("Stopping sound")});else console.error("No source to stop");else console.error("No source to stop")}clone(){const q=D.get(this),z=q.source&&typeof q.source.mediaStream!=="undefined";return new L({volume:q.volume,loop:q.loop,attack:q.attack,release:q.release,file:q.source&&q.source.buffer?q.source.buffer:void 0,wave:q.source&&q.source.frequency?{type:q.source.type,frequency:q.source.frequency.value}:void 0,input:z,audioFunction:q.source.onaudioprocess})}setVolume(q){this.volume=q}applyAttack(){const q=D.get(this);if(!q.gainNode)return;const z=q.context.currentTime;q.gainNode.gain.setValueAtTime(0,z),q.gainNode.gain.linearRampToValueAtTime(q.volume,z+q.attack),console.log("Attack applied")}applyRelease(q){const z=D.get(this);if(!z.gainNode)return;const A=z.context.currentTime;z.gainNode.gain.setValueAtTime(z.volume,A),z.gainNode.gain.linearRampToValueAtTime(0,A+z.release),setTimeout(q,z.release*1000),console.log("Release applied")}connect(q){D.get(this).gainNode.connect(q)}disconnect(q){D.get(this).gainNode.disconnect(q)}}var J=L;var H=new WeakMap;class R{constructor(q=[]){if(q.length===0)throw new Error("Group requires at least one sound");const z=q[0].context,A=z.createGain(),K={context:z,gainNode:A,sounds:q};H.set(this,K),q.forEach((I)=>{if(I instanceof J)I.connect(A),console.log("Sound connected to group gain node:",I);else console.error("Sound is not an instance of Sound class:",I)}),A.connect(z.destination)}get context(){return H.get(this).context}get gainNode(){return H.get(this).gainNode}get sounds(){return H.get(this).sounds}play(){this.sounds.forEach((q)=>q.play())}stop(){this.sounds.forEach((q)=>q.stop())}pause(){this.sounds.forEach((q)=>q.pause())}addSound(q){if(!(q instanceof J)){console.error("The sound is not an instance of Sound class:",q);return}const z=H.get(this);z.sounds.push(q),q.connect(z.gainNode),console.log("Added and connected new sound to group gain node:",q)}removeSound(q){const z=H.get(this),A=z.sounds.indexOf(q);if(A===-1){console.warn("The sound is not in the group");return}q.disconnect(z.gainNode),z.sounds.splice(A,1),console.log("Removed and disconnected sound from group gain node:",q)}set volume(q){if(q<0||q>1){console.warn("Volume value must be between 0 and 1.");return}H.get(this).gainNode.gain.value=q}get volume(){return H.get(this).gainNode.gain.value}}var V=R;window.Pluck={Sound:J,Group:V};
