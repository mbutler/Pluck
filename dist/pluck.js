var z=new WeakMap;class G{constructor(j={}){const A=new(globalThis.AudioContext||globalThis.webkitAudioContext),D=A.createGain(),C={context:A,source:null,audioBuffer:null,volume:j.volume||1,loop:j.loop||!1,attack:j.attack||0.04,release:j.release||0.04,gainNode:D,mediaStream:null};z.set(this,C),this.initialized=this.initSource(j).then(()=>{this.volume=C.volume})}get context(){return z.get(this).context}get source(){return z.get(this).source}set source(j){const q=z.get(this);q.source=j}get volume(){return z.get(this).volume}set volume(j){const q=z.get(this);if(j<0||j>1){console.warn("Volume value must be between 0 and 1.");return}if(q.volume=j,q.gainNode)q.gainNode.gain.value=j}get loop(){return z.get(this).loop}set loop(j){z.get(this).loop=j}get attack(){return z.get(this).attack}set attack(j){z.get(this).attack=j}get release(){return z.get(this).release}set release(j){z.get(this).release=j}get gainNode(){return z.get(this).gainNode}async initSource(j){if(j.file)await this.loadFromFile(j.file);else if(j.wave)this.initFromWave(j.wave);else if(j.input)await this.initFromInput();else if(j.audioFunction)this.initFromFunction(j.audioFunction);else this.initFromWave({type:"sine",frequency:440})}async loadFromFile(j){const q=z.get(this);try{console.log("Fetching sound file:",j);const D=await(await fetch(j)).arrayBuffer(),C=await q.context.decodeAudioData(D);q.audioBuffer=C,console.log("Sound file loaded:",j)}catch(A){console.error("Error loading sound file:",A)}}createSourceFromBuffer(){const j=z.get(this);if(!j.audioBuffer){console.error("No audio buffer to create source from");return}j.source=j.context.createBufferSource(),j.source.buffer=j.audioBuffer,j.source.loop=j.loop,j.source.onended=()=>{console.log("Sound playback ended"),j.source=null},console.log("Created source from buffer:",j.source),this.connectSourceToGainNode()}initFromWave(j){const q=z.get(this);q.source=q.context.createOscillator(),q.source.type=j.type||"sine",q.source.frequency.value=j.frequency||440,q.source.onended=()=>{console.log("Sound playback ended"),q.source=null},console.log("Created wave source:",q.source),this.connectSourceToGainNode()}async initFromInput(){const j=z.get(this),q=await navigator.mediaDevices.getUserMedia({audio:!0});j.mediaStream=q,j.source=j.context.createMediaStreamSource(q),this.connectSourceToGainNode(),console.log("Microphone input initialized")}initFromFunction(j){const q=z.get(this);q.source=q.context.createScriptProcessor(2048,1,1),q.source.onaudioprocess=j,this.connectSourceToGainNode()}connectSourceToGainNode(){const j=z.get(this);if(j.source)j.source.connect(j.gainNode),j.gainNode.connect(j.context.destination),console.log("Source connected to gain node");else console.error("No source to connect to gain node")}async play(j=0,q=0){await this.initialized;const A=z.get(this);if(A.context.state==="suspended")await A.context.resume();if(A.source)if(A.source instanceof MediaStreamAudioSourceNode)console.log("Playing media stream source");else if(A.source.start)A.source.start(A.context.currentTime+j,q),console.log("Playing sound");else console.error("Source has no start method");else if(A.audioBuffer)this.createSourceFromBuffer(),this.play(j,q);else console.error("No source or audio buffer available to play")}pause(){}stop(){const j=z.get(this);if(j.source)if(j.source instanceof MediaStreamAudioSourceNode)j.mediaStream.getTracks().forEach((A)=>A.stop()),j.mediaStream=null,console.log("Microphone input stopped");else if(j.source.stop)j.source.stop(),j.source=null,console.log("Stopping sound");else console.error("No source to stop")}clone(){const j=z.get(this),q=j.source&&typeof j.source.mediaStream!=="undefined";return new G({volume:j.volume,loop:j.loop,attack:j.attack,release:j.release,file:j.source&&j.source.buffer?j.source.buffer:void 0,wave:j.source&&j.source.frequency?{type:j.source.type,frequency:j.source.frequency.value}:void 0,input:q,audioFunction:j.source.onaudioprocess})}setVolume(j){this.volume=j}applyAttack(){const j=z.get(this);if(!j.gainNode)return;const q=j.context.currentTime;j.gainNode.gain.setValueAtTime(0,q),j.gainNode.gain.linearRampToValueAtTime(j.volume,q+j.attack),console.log("Attack applied")}applyRelease(j){const q=z.get(this);if(!q.gainNode)return;const A=q.context.currentTime;q.gainNode.gain.setValueAtTime(q.volume,A),q.gainNode.gain.linearRampToValueAtTime(0,A+q.release),setTimeout(j,q.release*1000),console.log("Release applied")}}var H=G;window.Pluck={Sound:H};
