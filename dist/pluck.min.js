var c=new WeakMap;class n{constructor(e={}){const t=e.context||new(window.AudioContext||window.webkitAudioContext),i=t.createGain(),r={context:t,source:null,audioBuffer:e.audioBuffer||null,volume:e.volume||1,loop:e.loop||!1,attack:e.attack||0.04,release:e.release||0.04,gainNode:i,mediaStream:e.input||null,clearBuffer:e.clearBuffer||!1,isPlaying:!1};c.set(this,r),this.initialized=this.initialize(e)}async initialize(e){try{await this.initSource(e),this.volume=e.volume||1}catch(t){console.error("Error initializing source:",t)}}get context(){return c.get(this).context}get source(){return c.get(this).source}set source(e){const t=c.get(this);t.source=e}get audioBuffer(){return c.get(this).audioBuffer}set audioBuffer(e){const t=c.get(this);t.audioBuffer=e}get volume(){return c.get(this).volume}set volume(e){const t=c.get(this);if(t.volume=e,t.gainNode)t.gainNode.gain.value=e}get loop(){return c.get(this).loop}set loop(e){const t=c.get(this);t.loop=e}get attack(){return c.get(this).attack}set attack(e){const t=c.get(this);t.attack=e}get release(){return c.get(this).release}set release(e){const t=c.get(this);t.release=e}get gainNode(){return c.get(this).gainNode}get mediaStream(){return c.get(this).mediaStream}set mediaStream(e){const t=c.get(this);t.mediaStream=e}get clearBuffer(){return c.get(this).clearBuffer}set clearBuffer(e){const t=c.get(this);t.clearBuffer=e}get isPlaying(){return c.get(this).isPlaying}set isPlaying(e){const t=c.get(this);t.isPlaying=e}async initSource(e){if(e.file)await this.loadFromFile(e.file);else if(e.wave)this.initFromWave(e.wave);else if(e.input)await this.initFromInput();else this.initFromWave({type:"sine",frequency:440})}async loadFromFile(e){try{console.log("Fetching sound file:",e);const i=await(await fetch(e)).arrayBuffer();this.audioBuffer=await this.context.decodeAudioData(i),this.createSourceFromBuffer(),console.log("Sound file loaded:",e)}catch(t){console.error("Error loading sound file:",t)}}createSourceFromBuffer(){if(!this.audioBuffer){console.error("No audio buffer to create source from");return}this.source=this.context.createBufferSource(),this.source.buffer=this.audioBuffer,this.source.loop=this.loop,this.source.onended=()=>{if(console.log("Sound playback ended"),this.isPlaying=!1,this.source=null,this.clearBuffer)this.audioBuffer=null},console.log("Created source from buffer:",this.source),this.connectSourceToGainNode()}initFromWave(e){this.source=this.context.createOscillator(),this.source.type=e.type||"sine",this.source.frequency.value=e.frequency||440,this.source.onended=()=>{console.log("Sound playback ended"),this.isPlaying=!1,this.source=null},this.connectSourceToGainNode()}async initFromInput(){try{const e=await navigator.mediaDevices.getUserMedia({audio:!0});this.mediaStream=e,this.source=this.context.createMediaStreamSource(e),this.connectSourceToGainNode()}catch(e){console.error("Error initializing microphone input:",e)}}connectSourceToGainNode(){if(this.source)this.source.connect(this.gainNode),this.gainNode.connect(this.context.destination),console.log("Source connected to gain node");else console.error("No source to connect to gain node")}async play(e=0){if(this.isPlaying=!0,await this.initialized,this.context.state==="suspended")await this.context.resume();if(!this.audioBuffer&&!this.source){console.error("No audio buffer or source available to play");return}if(this.audioBuffer)this.createSourceFromBuffer();if(this.mediaStream){console.log("Microphone input started");return}if(this.source&&this.source.start)this.applyAttack(),console.log("Starting source",this.source),this.source.start(this.context.currentTime,e);else console.error("No source to play"),this.isPlaying=!1}stop(){if(this.isPlaying=!1,this.mediaStream){this.mediaStream.getTracks().forEach((e)=>e.stop()),this.source.disconnect(),this.source=null,console.log("Microphone input stopped");return}if(this.source&&this.source.stop)this.applyRelease(()=>{if(this.source.stop(),this.source.disconnect(),this.source=null,this.clearBuffer)this.audioBuffer=null;console.log("Stopping sound")})}clone(){const e=c.get(this);return new n({context:e.context,audioBuffer:e.audioBuffer,volume:e.volume,loop:e.loop,attack:e.attack,release:e.release,input:this.mediaStream||null,clearBuffer:e.clearBuffer,file:this.source&&this.source.buffer?this.source.buffer:void 0,wave:this.source&&this.source.frequency?{type:this.source.type,frequency:this.source.frequency.value}:void 0})}applyAttack(){if(!this.gainNode)return;const e=this.context.currentTime;this.gainNode.gain.setValueAtTime(0,e),this.gainNode.gain.linearRampToValueAtTime(this.volume,e+this.attack),console.log("Attack applied")}applyRelease(){if(!this.gainNode)return;const e=this.context.currentTime;this.gainNode.gain.setValueAtTime(this.volume,e),this.gainNode.gain.linearRampToValueAtTime(0,e+this.release),console.log("Release applied")}connect(e){this.gainNode.connect(e)}disconnect(e){this.gainNode.disconnect(e)}}var l=n;class f{constructor(){this.queue=[]}enqueue(e,t){const i={item:e,priority:t};this.queue.push(i),this.bubbleUp(this.queue.length-1)}dequeue(){if(this.isEmpty())return null;const e=this.queue[0],t=this.queue.pop();if(this.queue.length>0)this.queue[0]=t,this.bubbleDown(0);return e.item}peek(){return this.queue[0]}isEmpty(){return this.queue.length===0}bubbleUp(e){const t=this.queue[e];while(e>0){const i=Math.floor((e-1)/2),r=this.queue[i];if(t.priority>=r.priority)break;this.queue[e]=r,e=i}this.queue[e]=t}bubbleDown(e){const t=this.queue.length,i=this.queue[e];while(!0){const r=2*e+1,a=2*e+2;let u=this.queue[r],o=this.queue[a],h=null;if(r<t){if(u.priority<i.priority)h=r}if(a<t){if(h===null&&o.priority<i.priority||h!==null&&o.priority<u?.priority)h=a}if(h===null)break;this.queue[e]=this.queue[h],e=h}this.queue[e]=i}remove(e){const t=this.queue.findIndex((r)=>r.item===e);if(t===-1)return!1;const i=this.queue.pop();if(t<this.queue.length)this.queue[t]=i,this.bubbleUp(t),this.bubbleDown(t);return!0}}var g=f;class m{constructor(){this.context=null,this.sounds=[],this.currentTime=0,this.lastTimestamp=0,this.isPlaying=!1,this.soundQueue=new g,this.events={onStart:[],onStop:[],onLoop:[],onSoundScheduled:[],onSoundPlayed:[],onEffectTriggered:[]}}on(e,t){if(this.events[e])this.events[e].push(t);else console.error(`Event ${e} is not supported.`)}triggerEvent(e,...t){if(this.events[e])this.events[e].forEach((i)=>i(...t))}async start(){this.context=new(window.AudioContext||window.webkitAudioContext),console.log("Audio context initialized",this.context),this.isPlaying=!0,this.triggerEvent("onStart"),await this.context.resume(),this.loop()}async loop(e=0){if(!this.isPlaying)return;this.currentTime=this.context.currentTime;while(!this.soundQueue.isEmpty()&&this.soundQueue.peek().priority<=this.currentTime){const t=this.soundQueue.dequeue(),{sound:i,time:r,offset:a,options:u}=t;if(console.log("node:",t),console.log(`Processing item scheduled for time: ${r}`),i){console.log("Playing sound:",i);try{await i.play(a),this.triggerEvent("onSoundPlayed",i,this.currentTime,a)}catch(o){console.error("Error playing sound:",o)}}}this.triggerEvent("onLoop"),requestAnimationFrame(()=>this.loop())}stop(){this.isPlaying=!1,this.triggerEvent("onStop")}scheduleSound(e,t,i=0,r={}){this.soundQueue.enqueue({sound:e,time:t,offset:i,options:r},t),console.log(`Scheduled sound at ${t} with offset ${i}`),console.log("Queue state after scheduling:",this.soundQueue),this.triggerEvent("onSoundScheduled",e,t,i,r)}rescheduleSound(e,t,i=0,r={}){this.soundQueue.remove(e),this.scheduleSound(e,t,i,r)}playNow(e){this.soundQueue.enqueue({sound:e,time:this.currentTime,offset:0,options:{}},this.currentTime),console.log(`Playing sound immediately at ${this.currentTime}`)}scheduleEffect(e,t){this.soundQueue.enqueue({effect:e,time:t},t)}async addSound(e,t=0,i,r={}){const a=new l({file:e,context:this.context,...r});await a.initialized,this.scheduleSound(a,i,t,r)}async playSound(e,t=0,i={}){if(!this.context){console.error("Audio context is not initialized. Call start() first.");return}const r=new l({file:e,context:this.context,...i});await r.initialized,await r.play(t),this.triggerEvent("onSoundPlayed",r,this.currentTime,t)}runEverySecond(){console.log("Every second")}}var y=m;var s=new WeakMap;class q{constructor(e=[]){if(e.length===0)throw new Error("Group requires at least one sound");const t=e[0].context,i=t.createGain(),r={context:t,gainNode:i,sounds:[],muted:!1};s.set(this,r),e.forEach((a)=>{if(a instanceof l)this.addSound(a);else console.error("Sound is not an instance of Sound class:",a)}),i.connect(t.destination)}get context(){return s.get(this).context}get gainNode(){return s.get(this).gainNode}get sounds(){return s.get(this).sounds}async play(){const t=s.get(this).sounds.map(async(i)=>{if(!i.isPlaying)try{await i.play(),i.isPlaying=!0}catch(r){console.error("Error playing sound:",r)}});await Promise.all(t)}async stop(){const t=s.get(this).sounds.map(async(i)=>{if(i.isPlaying)i.stop(),i.isPlaying=!1});await Promise.all(t)}async addSound(e){if(!(e instanceof l)){console.error("The sound is not an instance of Sound class:",e);return}const t=s.get(this);if(e.context!==t.context){console.error("Cannot add sound to group: mismatched audio contexts");return}t.sounds.push(e),e.connect(t.gainNode),console.log("Added and connected new sound to group gain node:",e)}async removeSound(e){const t=s.get(this),i=t.sounds.indexOf(e);if(i===-1){console.warn("The sound is not in the group");return}if(e.disconnect(t.gainNode),t.sounds.splice(i,1),console.log("Removed and disconnected sound from group gain node:",e),t.sounds.length===0)t.gainNode.disconnect(t.context.destination)}set volume(e){if(e<0||e>1){console.warn("Volume value must be between 0 and 1.");return}s.get(this).gainNode.gain.value=e}get volume(){return s.get(this).gainNode.gain.value}setVolumeGradually(e,t=1){if(e<0||e>1){console.warn("Volume value must be between 0 and 1.");return}const i=s.get(this).gainNode,r=this.context.currentTime;i.gain.setValueAtTime(i.gain.value,r),i.gain.linearRampToValueAtTime(e,r+t),console.log(`Volume set to ${e} over ${t} seconds`)}mute(){const e=s.get(this);if(!e.muted)e.previousVolume=this.volume,this.volume=0,e.muted=!0,console.log("Group muted")}unmute(){const e=s.get(this);if(e.muted)this.volume=e.previousVolume,e.muted=!1,console.log("Group unmuted")}}var B=q;window.Pluck={Timeline:y,Sound:l,Group:B};
