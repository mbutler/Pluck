var a=new WeakMap;class u{constructor(t={}){const e=t.context||new(window.AudioContext||window.webkitAudioContext),i=e.createGain(),c={fileName:t.file||null,context:e,source:null,audioBuffer:t.audioBuffer||null,volume:t.volume||1,loop:t.loop||!1,attack:t.attack||0.04,release:t.release||0.04,offset:t.offset||0,gainNode:i,mediaStream:t.input||null,clearBuffer:t.clearBuffer||!1,isPlaying:!1};a.set(this,c),this.initialized=this.initialize(t)}async initialize(t){try{await this.initSource(t),this.volume=t.volume||1}catch(e){console.error("Error initializing source:",e)}}get fileName(){return a.get(this).fileName}get context(){return a.get(this).context}get source(){return a.get(this).source}set source(t){const e=a.get(this);e.source=t}get audioBuffer(){return a.get(this).audioBuffer}set audioBuffer(t){const e=a.get(this);e.audioBuffer=t}get volume(){return a.get(this).volume}set volume(t){const e=a.get(this);if(e.volume=t,e.gainNode)e.gainNode.gain.value=t}get loop(){return a.get(this).loop}set loop(t){const e=a.get(this);e.loop=t}get attack(){return a.get(this).attack}set attack(t){const e=a.get(this);e.attack=t}get release(){return a.get(this).release}set release(t){const e=a.get(this);e.release=t}get offset(){return a.get(this).offset}set offset(t){const e=a.get(this);e.offset=t}get gainNode(){return a.get(this).gainNode}get mediaStream(){return a.get(this).mediaStream}set mediaStream(t){const e=a.get(this);e.mediaStream=t}get clearBuffer(){return a.get(this).clearBuffer}set clearBuffer(t){const e=a.get(this);e.clearBuffer=t}get isPlaying(){return a.get(this).isPlaying}set isPlaying(t){const e=a.get(this);e.isPlaying=t}async initSource(t){if(t.file)await this.loadFromFile(t.file);else if(t.wave)this.initFromWave(t.wave);else if(t.input)await this.initFromInput();else this.initFromWave({type:"sine",frequency:440})}async loadFromFile(t){try{console.log("Fetching sound file:",t);const i=await(await fetch(t)).arrayBuffer();this.audioBuffer=await this.context.decodeAudioData(i),this.createSourceFromBuffer(),console.log("Sound file loaded:",t)}catch(e){console.error("Error loading sound file:",e)}}createSourceFromBuffer(){if(!this.audioBuffer){console.error("No audio buffer to create source from");return}this.source=this.context.createBufferSource(),this.source.buffer=this.audioBuffer,this.source.loop=this.loop,this.source.onended=()=>{if(console.log("Sound playback ended"),this.isPlaying=!1,this.source=null,this.clearBuffer)this.audioBuffer=null},console.log("Created source from buffer:",this.source),this.connectSourceToGainNode()}initFromWave(t){this.source=this.context.createOscillator(),this.source.type=t.type||"sine",this.source.frequency.value=t.frequency||440,this.source.onended=()=>{console.log("Sound playback ended"),this.isPlaying=!1,this.source=null},this.connectSourceToGainNode()}async initFromInput(){try{const t=await navigator.mediaDevices.getUserMedia({audio:!0});this.mediaStream=t,this.source=this.context.createMediaStreamSource(t),this.connectSourceToGainNode()}catch(t){console.error("Error initializing microphone input:",t)}}connectSourceToGainNode(){if(this.source)this.source.connect(this.gainNode),this.gainNode.connect(this.context.destination),console.log("Source connected to gain node");else console.error("No source to connect to gain node")}async play(){if(this.isPlaying=!0,await this.initialized,this.context.state==="suspended")await this.context.resume();if(!this.audioBuffer&&!this.source){console.error("No audio buffer or source available to play");return}if(this.audioBuffer)this.createSourceFromBuffer();if(this.mediaStream){console.log("Microphone input started");return}if(this.source&&this.source.start)this.applyAttack(),console.log("Starting source",this.source),console.log("offset:",this.offset),this.source.start(this.context.currentTime,this.offset);else console.error("No source to play"),this.isPlaying=!1}stop(){if(this.isPlaying=!1,this.mediaStream){this.mediaStream.getTracks().forEach((t)=>t.stop()),this.source.disconnect(),this.source=null,console.log("Microphone input stopped");return}if(this.source&&this.source.stop)this.applyRelease(()=>{if(this.source.stop(),this.source.disconnect(),this.source=null,this.clearBuffer)this.audioBuffer=null;console.log("Stopping sound")})}clone(){const t=a.get(this);return new u({context:t.context,audioBuffer:t.audioBuffer,volume:t.volume,loop:t.loop,attack:t.attack,release:t.release,input:this.mediaStream||null,clearBuffer:t.clearBuffer,file:this.source&&this.source.buffer?this.source.buffer:void 0,wave:this.source&&this.source.frequency?{type:this.source.type,frequency:this.source.frequency.value}:void 0})}applyAttack(){if(!this.gainNode)return;const t=this.context.currentTime;this.gainNode.gain.setValueAtTime(0,t),this.gainNode.gain.linearRampToValueAtTime(this.volume,t+this.attack),console.log("Attack applied")}applyRelease(){if(!this.gainNode)return;const t=this.context.currentTime;this.gainNode.gain.setValueAtTime(this.volume,t),this.gainNode.gain.linearRampToValueAtTime(0,t+this.release),console.log("Release applied")}connect(t){this.gainNode.connect(t)}disconnect(t){this.gainNode.disconnect(t)}}var h=u;class g{constructor(){this.queue=[]}enqueue(t,e){const i={item:t,priority:e};this.queue.push(i),this.bubbleUp(this.queue.length-1)}dequeue(){if(this.isEmpty())return null;const t=this.queue[0],e=this.queue.pop();if(this.queue.length>0)this.queue[0]=e,this.bubbleDown(0);return t.item}peek(){return this.queue[0]}isEmpty(){return this.queue.length===0}bubbleUp(t){const e=this.queue[t];while(t>0){const i=Math.floor((t-1)/2),c=this.queue[i];if(e.priority>=c.priority)break;this.queue[t]=c,t=i}this.queue[t]=e}bubbleDown(t){const e=this.queue.length,i=this.queue[t];while(!0){const c=2*t+1,o=2*t+2;let f=this.queue[c],n=this.queue[o],l=null;if(c<e){if(f.priority<i.priority)l=c}if(o<e){if(l===null&&n.priority<i.priority||l!==null&&n.priority<f?.priority)l=o}if(l===null)break;this.queue[t]=this.queue[l],t=l}this.queue[t]=i}remove(t){const e=this.queue.findIndex((c)=>c.item===t);if(e===-1)return!1;const i=this.queue.pop();if(e<this.queue.length)this.queue[e]=i,this.bubbleUp(e),this.bubbleDown(e);return!0}}var y=g;var r=new WeakMap;class m{constructor(t={}){const e={context:null,currentTime:0,isPlaying:!1,soundQueue:new y,events:{onStart:[],onStop:[],onLoop:[],onSoundScheduled:[],onSoundPlayed:[],onEffectTriggered:[]}};r.set(this,e)}get context(){return r.get(this).context}set context(t){const e=r.get(this);e.context=t}get currentTime(){return r.get(this).currentTime}set currentTime(t){const e=r.get(this);e.currentTime=t}get isPlaying(){return r.get(this).isPlaying}set isPlaying(t){const e=r.get(this);e.isPlaying=t}get soundQueue(){return r.get(this).soundQueue}get events(){return r.get(this).events}on(t,e){const i=r.get(this);if(i.events[t])i.events[t].push(e);else console.error(`Event ${t} is not supported.`)}off(t,e){const i=r.get(this);if(i.events[t])i.events[t]=i.events[t].filter((c)=>c!==e);else console.error(`Event ${t} is not supported.`)}triggerEvent(t,e,i){const c=r.get(this);if(c.events[t])c.events[t].forEach((o)=>o(e,i))}async start(){this.context=new(window.AudioContext||window.webkitAudioContext),console.log("Audio context initialized",this.context),this.isPlaying=!0,this.triggerEvent("onStart"),await this.context.resume(),this.loop()}async loop(){if(!this.isPlaying)return;this.currentTime=this.context.currentTime;while(!this.soundQueue.isEmpty()&&this.soundQueue.peek().priority<=this.currentTime){const t=this.soundQueue.dequeue(),{sound:e,time:i}=t;if(console.log(`Processing item scheduled for time: ${i}`),e){console.log("Playing sound:",e);try{this.triggerEvent("onSoundPlayed",e,this.currentTime),await e.play()}catch(c){console.error("Error playing sound:",c)}}}this.triggerEvent("onLoop"),requestAnimationFrame(()=>this.loop())}stop(){this.isPlaying=!1,this.triggerEvent("onStop")}scheduleSound(t,e){this.soundQueue.enqueue({sound:t,time:e},e),console.log("Queue state after scheduling:",this.soundQueue),this.triggerEvent("onSoundScheduled",t,e)}rescheduleSound(t,e,i={}){this.soundQueue.remove(t),this.scheduleSound(t,e)}playNow(t){this.soundQueue.enqueue({sound:t,time:this.currentTime},this.currentTime),console.log(`Playing sound immediately at ${this.currentTime}`)}async addSound(t,e,i={}){const c=new h({file:t,...i});await c.initialized,this.scheduleSound(c,e)}async playSound(t,e={}){if(!this.context){console.error("Audio context is not initialized. Call start() first.");return}const i=new h({file:t,...e});await i.initialized,await i.play(),this.triggerEvent("onSoundPlayed",i,this.currentTime)}runEverySecond(){console.log("Every second")}}var q=m;var s=new WeakMap;class B{constructor(t=[]){if(t.length===0)throw new Error("Group requires at least one sound");const e=t[0].context,i=e.createGain(),c={context:e,gainNode:i,sounds:[],muted:!1};s.set(this,c),t.forEach((o)=>{if(o instanceof h)this.addSound(o);else console.error("Sound is not an instance of Sound class:",o)}),i.connect(e.destination)}get context(){return s.get(this).context}get gainNode(){return s.get(this).gainNode}get sounds(){return s.get(this).sounds}async play(){const e=s.get(this).sounds.map(async(i)=>{if(!i.isPlaying)try{await i.play(),i.isPlaying=!0}catch(c){console.error("Error playing sound:",c)}});await Promise.all(e)}async stop(){const e=s.get(this).sounds.map(async(i)=>{if(i.isPlaying)i.stop(),i.isPlaying=!1});await Promise.all(e)}async addSound(t){if(!(t instanceof h)){console.error("The sound is not an instance of Sound class:",t);return}const e=s.get(this);if(t.context!==e.context){console.error("Cannot add sound to group: mismatched audio contexts");return}e.sounds.push(t),t.connect(e.gainNode),console.log("Added and connected new sound to group gain node:",t)}async removeSound(t){const e=s.get(this),i=e.sounds.indexOf(t);if(i===-1){console.warn("The sound is not in the group");return}if(t.disconnect(e.gainNode),e.sounds.splice(i,1),console.log("Removed and disconnected sound from group gain node:",t),e.sounds.length===0)e.gainNode.disconnect(e.context.destination)}set volume(t){if(t<0||t>1){console.warn("Volume value must be between 0 and 1.");return}s.get(this).gainNode.gain.value=t}get volume(){return s.get(this).gainNode.gain.value}setVolumeGradually(t,e=1){if(t<0||t>1){console.warn("Volume value must be between 0 and 1.");return}const i=s.get(this).gainNode,c=this.context.currentTime;i.gain.setValueAtTime(i.gain.value,c),i.gain.linearRampToValueAtTime(t,c+e),console.log(`Volume set to ${t} over ${e} seconds`)}mute(){const t=s.get(this);if(!t.muted)t.previousVolume=this.volume,this.volume=0,t.muted=!0,console.log("Group muted")}unmute(){const t=s.get(this);if(t.muted)this.volume=t.previousVolume,t.muted=!1,console.log("Group unmuted")}}var b=B;window.Pluck={Timeline:q,Sound:h,Group:b};
